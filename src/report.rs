//Take care of long ball/small ball tactic report
use crate::hands::*;
use crate::args::*;
use crate::helper::*;
use std::collections::HashMap;

pub struct Report{
    pub betsize: (&'static str,f32),
    pub distribution: Option<HashMap<HandType,f32>>, //at flop , calculate fullhouse/flush/straight/trips/two pairs/pair %
}

impl Report{
    pub fn new()-> Report{
        Report{
            betsize: ("Check/Fold",0.0),
            distribution: None,
        }
    }

    pub fn print_report(&mut self,info: DsolverArgs){
        let mut distribution=String::from("");
        //generate report
        match info.stage{
        Stage::PreFlop(pfinfo)=>{
            pfinfo.validate_int().unwrap_or_else(|err|{eprintln!("Error: {}", err);});
            match info.strategy{
                Strategy::LongBall=>{self.longball_preflop(pfinfo);}
                Strategy::SmallBall=>{self.smallball_preflop(pfinfo);}
            }
        },
        Stage::Flop(finfo)=>{
            finfo.validate_cards().unwrap_or_else(|err|{eprintln!("Error: {}", err);});
            let finfo_ref=finfo.clone();
            let distrib=finfo.distribution.clone();
            self.odd_distribution(finfo_ref);
            match info.strategy{
                Strategy::LongBall=>{self.longball_flop(finfo);}
                Strategy::SmallBall=>{self.smallball_flop(finfo);}
            }
            //print distribution
            if distrib=='y' {self.format_distribution(&mut distribution);}
        }
        }

        let movement:String;
        if self.betsize.1==0.0 {movement=self.betsize.0.to_string();}
        else{ movement=format!("Bet {} {}", self.betsize.1, self.betsize.0);}
        println!("\nMove: {}\n{}",movement,distribution);
    }

    fn format_distribution(&self,distrib_str:&mut String){
        distrib_str.push_str("\nHand Odd by River:\n");
        let map=self.distribution.as_ref().unwrap().clone();
        //sort a hashmap by value, generated by chatGPT
        let mut keys = map.keys().cloned().collect::<Vec<_>>();
        keys.sort_by(|a, b| map.get(b).unwrap().partial_cmp(map.get(a).unwrap()).unwrap());

        for hand in keys {
            distrib_str.push_str(format!("{:-<14}{:.1}%\n", hand, map[&hand]).as_str());
        }
    }

    fn longball_preflop(&mut self,info: PreFlopCommand){
        //classify strength
        let strength=hole_strength(&parse_hole(info.hole));
        let mut raise=false;
        //include position and numbers of limper/raiser to figure out raise/call/fold
        let pos=info.position;
        //1. have raiser
        if info.caller>0 {
            if pos<=2 && strength==1 {self.betsize.0="Call";}
            if strength==0 {raise=true;}
        }
        //2. have limper
        else if info.limper>0{
            match pos{
                //blind position
                1|2 =>{
                    if strength==0 {raise=true;}
                    else if strength==1 {self.betsize.0="Call";}
                }
                //other position
                _=>{
                    if strength<=1 {raise=true;}
                }
            }
        }
        //When no-one raise and limp
        else{
            match pos{
            //early position: utg, utg+1
            3|4 =>{
                if strength<=1 {raise=true;}
            },
            //mid position: mp, lowjack, highjack  (blind position has same judgment)
            5|6|7|1|2 => {
                if strength<=2 {raise=true;}
            },
            8|9 => {
                if strength<=3 {raise=true;}
            }
            _=>()
            }
        }
        //determine bet size
        if raise{
            if info.caller>0 {
                self.betsize.0="Bet";
                let num=info.caller;
                self.betsize.1= match num{
                    0=>5.0,
                    1..=3=>7.0,
                    _=>9.0,
                }
            }else if info.limper>0{
                self.betsize.0="BB";
                let num=info.limper;
                self.betsize.1= match num{
                    0=>5.0,
                    1..=3=>7.0,
                    _=>9.0,
                }
            }else {
                self.betsize.0="BB";
                self.betsize.1=5.0;
            }
        }
    }

    fn smallball_preflop(&mut self,info: PreFlopCommand){
        //classify strength
        let strength=hole_strength(&parse_hole(info.hole));
        let mut bet=false;
        //2.5BB bet or fold
        if strength<=4 {bet=true;}
        //determine bet size
        if bet{
                self.betsize.0="BB";
                self.betsize.1=2.5;
        }
    }

    fn longball_flop(&mut self,info: FlopCommand){
        //check anything better than pair, and check draw
        let mut bet=false;
        for (key, val) in self.distribution.as_ref().unwrap().iter(){
            if *val==100.0 {bet=true;}
            if (*key==HandType::Straight || *key==HandType::Flush) && *val>30.0 {bet=true;}
        }
        //check pair
        if !bet {
            if let Some(have_pair)=flop_top_pair(&parse_hole(info.hole.clone()),&parse_board(info.hole,info.board)){
                if have_pair {bet=true;}
            }
        }
        //determine bet size
        if bet {
            self.betsize.0="Pot";
            self.betsize.1=1.0;
        }
    }

    fn smallball_flop(&mut self,info: FlopCommand){
        //check anything better than pair
        let mut bet=false;
        //check raise condition
        for (key, val) in self.distribution.as_ref().unwrap().iter(){
            if (*key==HandType::FourOfAKind || *key==HandType::FullHouse || *key==HandType::Flush || *key==HandType::Straight) && *val==100.0
            {
                bet=true;
                self.betsize.0="Check Raise";
                self.betsize.1=0.6;}
        }
        //bet condition
        if !bet{
            for (key, val) in self.distribution.as_ref().unwrap().iter(){
            if (*key==HandType::ThreeOfAKind || *key==HandType::TwoPair) && *val==100.0
            {
                bet=true;
                self.betsize.0="Pot";
                self.betsize.1=0.6;
            }
        }
        }
        if !bet{
            if self.distribution.as_ref().unwrap()[&HandType::Straight] > 30.0 && self.distribution.as_ref().unwrap()[&HandType::Flush] > 30.0
            {
                bet=true;
                self.betsize.0="Pot";
                self.betsize.1=0.6;
            }
        }
        //pair condition
        let hole_str:&str=&info.hole;
        if !bet{
            if let Some(have_pair)=flop_top_pair(&parse_hole(hole_str.to_string()),&parse_board(hole_str.to_string(),info.board)){
            //top pair -> bet
                if have_pair {
                self.betsize.0="Pot";
                self.betsize.1=0.6;
            }
            //mid pair -> check call
                else if hole_min(&parse_hole(hole_str.to_string()))>10 {
                self.betsize.0="Check Call";
                self.betsize.1=0.0;
            }
            }
        }
    }

    fn odd_distribution(&mut self,info: FlopCommand){
        let mut distrib=HashMap::new();
        let distrib_vec=flop_distribution(&parse_board(info.hole,info.board));
        //form hashmap
        distrib.insert(HandType::TwoPair,distrib_vec[0]);
        distrib.insert(HandType::ThreeOfAKind,distrib_vec[1]);
        distrib.insert(HandType::Straight,distrib_vec[2]);
        distrib.insert(HandType::Flush,distrib_vec[3]);
        distrib.insert(HandType::FullHouse,distrib_vec[4]);
        distrib.insert(HandType::FourOfAKind,distrib_vec[5]);
        self.distribution=Some(distrib);
    }
 }